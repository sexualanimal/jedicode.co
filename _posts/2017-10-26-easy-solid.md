---
layout:     post
title:      SOLID простым языком
date:       2017-10-26 17:04:10
summary:    Тут я попытаюсь максимально просто и в тот же момент максимально информативно вам пояснить что же такое SOLID и почему вам его нужно знать.
categories: java design principles
---

**SOLID** - [акроним](https://ru.wikipedia.org/wiki/Акроним), который описывает пять дизайн принципов программирования, каждый из которых является разъяснением того как нужно писать код, это своего рода набор правил, которые стоит не только заучить, но и понимать.

Если до этого момента вы небыли знакомы с SOLID то после их изучения вы поймете что и раньше вы уже использовали пускай не все но часть из них, не понимая этого.

### SRP: Single Responsibility Principle

Это первый принцип говорит о том, что класс или же интерфейс должен иметь одно назначение то есть решать одну поставленную задачу.

***Что даст вам этот принцип?***

Вы получите то, что является золотым Граалем в программировании, а именно **слабосвязанный код**, так как каждый ваш класс будет отвечать за решение определенной задачи, и такое явление как модификация логики вашего класса не потянет за собой ряд других исправлений, других классов.

Это достигается путем соблюдения SRP на протяжении всего жизненного цикла проекта.

> *Также важно помнить, что создав класс или интерфейс который был предназначен для решения одной конкретной задачи соблюдая SRP со временем в результате роста функциональности может нарушить этот принцип.* 

Поэтому важно следить за всеми изменениями в коде и не допускать этого путем разделения бизнес-логики на два отдельных класса. И чтобы не упустить такие моменты на проекте должен присутствовать **анализатор кода** и **код ревью**.

### OCP: Open/Closed Prociple

Означает то, что вы должны давать возможность только расширять ваши классы, но не давать возможности модифицировать его существующее поведение.

Чаще всего нарушение этого принципа встречается при использовании наследования, где путем переопределения в наследнике можно модифицировать базовое поведение родительского класса.

Придерживаясь этого принципа конкретно в Java можно с помощью ключевого слова `final` который запретит дальнейшей модификации метода или же свойства класса.

###LSP: Liskov Substitution Principle

Создавая наследников одного и того же интерфейса или абстрактного класса, они не должны менять поведения базового класса. То есть имея две реализации **B** и **C** класса **A** мы можем с легкость менять реализации и получать одинаковое конечное поведение обоих реализаций.

> *Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.*

Очень круто это показывает изображение ниже:

![Liskov Substitution Principle](/images/posts/posts/2018-10-24/LiskovSubtitutionPrinciple.jpg)

**Преимущества:**

Соблюдая этот принцип, вы получаете вполне ожидаемое поведение всех нижестоящих классов а именно родительских классов, которые расширяют предка.

**Нарушение LSP**

Как показывает изображение выше:

> *Выглядит как утка, квакает, как утка, но нуждается в батарейках - что есть прямым нарушением абстракция.*

### ISP: Interface Segregation Principle

Ориентирован на то, что ***вместо одно*** интерфейса, который бы решал обширное количество задач лучше предоставить ***несколько изолированных*** интерфейсов, каждый из которых нацеленных на решение одной конкретной задачи.

**Преимущества:**

Теперь, когда вам нужно предоставить решение клиенту, вам достаточно предоставить решение конкретного интерфейса, вместо использования одного общего. Также делает более читабельным и понимаемым то что, как и какую задачу решает интерфейс, тем самым позволив легкую дальнейшую поддержку данному интерфейсу не задевая другие.

### DIP: Dependecy Injection Principle

Основная идея принципа это не способствовать предоставлению зависимостей самостоятельно, а получать их с какого-то контейнера. Ярким примером этого есть **DI** *(Dependency Injection)*, также это может быть кокой либо другой ресурс, предоставляющий вам эти зависимости.

**Нарушение DIP:**

Как только вы начинаете заботится о предоставлении зависимости внутри класса это и есть нарушением DIP, а также такой подход делает ваш код сильно связанным и усложняет его со временем со стороны поддержки.

#### Ссылки

Видео: [Николай Алименков — Парадигмы ООП](https://youtu.be/G6LJkWwZGuc)